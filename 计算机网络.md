# 计算机网络

## TCP 

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

**序列号**：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

  **确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

  **控制位：**

  - *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
  - *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
  - *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
  - *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。

![image-20220726203045335](https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/image-20220726203045335.png)





抓包三次握手

![image-20220713195415533](https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/image-20220713195415533.png)

<img src="https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/image-20220721010433438.png" alt="image-20220721010433438" style="zoom:50%;" />

四次挥手

![image-20220713195027818](https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/image-20220713195027818.png)



### 1.TCP重传

#### 超时重传、快速重传



**超时重传：**

该重传机制在发送数据时，将会设定一个定时器，当超过指定的时间后，没有收到对方的ACK报文，就会启动**超时重传**，重发该数据。

超时重传一般发生在：

* 数据包丢失 ：发送的数据包丢失，对方未收到该数据包，于是超过设定时间后再次发送该数据
* ACK确认应答丢失：发送的数据包被对方成功接受到，但对方的ACK确认应答丢失，在超过设定时间后同样会再次发送该数据

RTT往返时延：数据从发送到接收到确认应答的时间段

RTO超时重传时间：超时重传机制所设定的定时器，超时重传时间应该略大于RTT时间。 

超时重传策略：

**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**



linux中可以设置最大重传次数，但并不是一定达到次数才断开连接，还会根据最大超时时间来判断，因为每一次超时时间都是上一次的二倍，因此可以根据第一次超时时间计算出最大超时时间。

在重传过程中，先达到**最大重传次数，或者最大重传时间**，系统内核就会判断该连接有问题，通过socket接口告诉进程该TCP连接有问题，随后断开该连接。



**快速重传：**

客户端向服务端发送的某个数据包丢失后，如果服务端连续三次向客户端发送相同的ACK报文请求那个丢失的数据包，客户端将会启动快速重传机制，会在定时器过期之前，重传丢失的报文段。



#### SACK方法及Duplicate SACK

SACK时 TCP 头部的的选项，它可以将缓存的地图发给发送方。

即当有报文失序到达时，接收方的SACK信息将会告诉发送方哪些被接收到了、哪些未被接收到，从而只发送未被接收的报文段。

（双方必须都支持SACK才能启用）



D-SACK 主要用于通过SACK告诉发送方有哪些数据被**重复**接收了（服务端ACK丢失，客户端未收到ACK以为自己所发送信息丢失）

主要好处：

* 让发送方知道，是ACK丢失，不是自己发送数据包丢失
* 可以知道发送方的数据包有没有被延迟
* 网络中有没有复制发送方的数据包

例如发送方的某报文成功接受，但ACK丢失，触发超时重传，则会再次发送该报文，而接收方回复中将会通过SACK告诉发送方，该报文被重复发送。

### 2.滑动窗口

窗口的实现是操作系统开辟的缓存空间，发送方在收到确认应答之前，必须将缓冲区内的数据保留，按期收到ACK后，再将数据清除。

通过累计应答，就算中间某个确认应答丢失，也可以通过后面的确认应答ACK来确定之前的报文是否有丢失。

**窗口大小**就是指**无需等待确认应答，而可以继续发送数据的最大值**。

另外，TCP头部中有Window字段，该字段是接收端 告诉 发送端 自己还有多少缓冲空间可以接受数据，发送端通过该字段来发送数据。因此，窗口大小是由接收端决定的。

发送方窗口：

<img src="https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/image-20220721224417810.png" alt="image-20220721224417810" style="zoom:67%;" />



接收方窗口：

![image-20220721231526657](https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/image-20220721231526657.png)



TCP的**流量控制**便是通过滑动窗口机制实施的。接收方根据自己的接受能力来调整窗口大小，从而调整发送方的发送数据量，实现流量控制。



**操作系统缓冲区和滑动窗口**

服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据：

当接收端应用程序没有及时读取缓存时，例如接受方接受到长度未140的数据包，但只读取40，剩下100未读取留在缓冲区，因此接收端会将接受窗口减小100，在并在ACK中带上窗口长度发送给发送端。







### 3.已建立连接的TCP,收到SYN会发生什么

一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 establish 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理

TCP连接是由四元组确定 ：**源端口 目的端口 源地址 目的地址 **

该场景中目的端口 源地址 目的地址是不变的，因此通过判断SYN报文中源端口是否与上一次连接的源端口一致：

* **源端口不一致**：因为**四元组不同**，因此服务端会认为是新的连接要建立，于是通过三次握手建立新的连接。

  之前的连接会继续保持，直到**服务端发送数据包**给客户端，因为客户端的连接已经关闭了，因此客户端会回复RST报文，服务器收到后便关闭该连接。 如果服务器一直没有发送数据包给客户端，在超过一段时间以后，**TCP保活机制**就会开启，检测到客户端没有存活后，接着服务端就会释放该连接。

* **源端口一致**：客户端发送**相同四元组**的SYN包后，因为客户端所发送的SYN包序列号是乱序的（序列号初始化），处于**establish** 状态（三次握手结束）的服务端将会回复一个携带正确序列号和和确认号的ACK包（针对上一次连接），该ACK称为 **Challenge ACK**，客户端收到challenge ACK 后发现也不是自己期望收到的，于是就回复 RST 报文（针对challenge ACK），服务端收到后，就会释放掉连接。

  

<img src="https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/image-20220721015558907.png" alt="image-20220721015558907" style="zoom: 67%;" />



### 4.未开启 TCP keepalive ，一方突然宕机

 **TCP keepalive TCP保活机制：**每隔一个时间段，发送一个探测报文，该报文携带数据量极小，连续几个探测报文都没得到响应，便认为当前的TCP	连接已经死亡，系统内核将错误信息通知给上层应用程序。

TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。

应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 `SO_KEEPALIVE` 选项才能够生效。

（保活时间、保活探测的次数、保活探测的时间间隔在Linux内核有对应的参数）

**无数据传输：**

客户端主机崩溃：在未开启TCP keepalive 并且双方一直无数据交互的情况下，服务端无法得知客户端的存活情况，因此会一直维持 **ESTABLISHED**状态，直到服务端重启进程。

客户端进程崩溃：即使没有开启TCP keepalive ，且双方也没有数据交互，在进程崩溃后，客户端会向服务端发送FIN报文 来进行四次挥手。（进程崩溃的一方，其系统内核可以感知到该进程崩溃，从而向对方发送FIN报文关闭连接）

 **有数据传输：**

客户端宕机后，**迅速重启**：因为服务端发送的报文都没有得到响应，因此会启动超时重传机制，在超时重传的过程中，客户端又重新启动后，客户端系统内核接收到服务端发送的报文以后将报文信息传递给对应进程：

* 客户端上没有进程建通该TCP报文的目标端口号，客户端系统内核就会回复RST报文重置TCP连接
* 有进程监听该目标端口号，但因为重启，该TCP连接的socket结构丢失，就会回复RST报文重置连接。

因此只要一方重启，都会发送RST报文来重置之前的TCP连接。



如果客户端宕机后一直**没有重启**，**在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传**。





### 5.拔掉网线，原来的TCP连接发生什么

拔掉网线本身不会改变客户端的TCP连接状态，只能算网络传输情况不好，客户端和服务端还是处于 ESTABLISHED状态。

**有数据传输：**

服务端向客户端发送数据报文得不到响应后，等待一定时间就会触发超时重传，如果超时重传过程中重新插上网线，那么客户端收到服务端发来报文后会响应报文，如果一直没有插上网线，那么等超过最大重传次数或者最大重传时间以后，内核就会判断该连接有问题，通过socket接口告诉应用程序该tcp连接有问题，于是服务端tcp连接断开。等插回网线以后，客户端向服务端发送数据，因为服务端没有与客户端相同四元组的TCP连接，因此回复RST报文，客户端收到后就会释放TCP连接。



**无数据传输：**

无数据传输的情况下还得分为有无开启**TCP keepalive**机制（TCP保活机制）

开启TCP keepalive：当拔掉网线，并且双方并无数据传输，那么**超过设置的保活时间**tcp_keepalive_time以后，TCP保活机制启动，会每隔设置的**检测间隔**向客户端发送探测报文，**如果达到最大检测次数**，系统内核将错误信息通知上层应用程序，然后中断本次连接，如果**有响应**那么保活时间重置。

在默认设置中 ，Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。

没开启 TCP keepalive 的情况下，并且一直无数据传输，那么双方就会一直保持 连接。





### 6.在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？

<img src="https://test-1309023885.cos.ap-guangzhou.myqcloud.com/typora/74b53919396dcda634cfd5b5795cbf16.png" alt="图片" style="zoom:67%;" />

处于TIME_WAIT状态的连接收到SYN后，或判断 序列号和时间戳是否合法

- **合法 SYN**：

  * 客户端的 SYN 的**「序列号」**比服务端「期望下一个收到的序列号」要**大**
  * SYN 的**「时间戳」**比服务端「最后收到的报文的时间戳」要**大**。

- **非法 SYN**：

  * 客户端的 SYN 的**「序列号」**比服务端「期望下一个收到的序列号」要**小**
  * SYN 的**「时间戳」**比服务端「最后收到的报文的时间戳」要**小**。

  如果双方都没有开启TCP时间戳机制，那么只判断序列号。

  

  收到**合法SYN**以后，会重用次四元组连接，跳过2MSL而转变为SYN_RECV状态，接着进行建立连接过程。

  

  收到**非法SYN**以后，服务器会回复一个第四次挥手的确认ACK报文，客户端收到该ACK报文后发现不是自己期望收到的确认号ACK num，于是回复 RST 报文给客户端。

  客户端等待一段时间还是没收到 SYN + ACK （第二次握手）后，就会超时重传 SYN 报文，重传次数达到最大值后，就会断开连接。



